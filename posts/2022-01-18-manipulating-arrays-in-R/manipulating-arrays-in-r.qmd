---
title: "Manipulating arrays with dynamic dimensions in R"
description: |
  Challenges and solutions for creating functions to manipulate arrays in R when the number of dimensions is unknown. 
author:
  - name: Emi Tanaka
    url: https://emitanaka.org
    affiliation: Monash University
    affiliation_url: https://numbat.space/
date: 2022-01-18
categories: [R, programming]
format:
  html:
    highlight: default
    toc: true
    toc_float: true
image: https://www.r-project.org/Rlogo.png
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Introduction to `array`s in R

Below I am creating an array of dimensions $3 \times 2 \times 4$ with each entry containing a unique value.

```{r}
x <- array(1:24, dim = c(3, 2, 4))
x
class(x)
```

You can access the entry $(1, 1, 1)$, i.e. the cell value in first entries of each dimension, in R by:

```{r}
x[1, 1, 1]
```

If you want the entries $(i, 1, 1)$ where $i = 1, 2, 3$ then you can leave the first element blank in R like below:

```{r}
x[, 1, 1]
```

In the above code, the result is a vector but if you wanted to keep the array structure as is then you could add `drop = FALSE` like below:

```{r}
x[, 1, 1, drop = FALSE]
```

If you want the entries $(1, j, k)$ where $j = 1, 2$ and $k = 1, 2, 3, 4$, then you can leave the first two entries in the square bracket like below: 

```{r}
x[1, , ]
```

The above result isn't actually a vector but a two dimensional array, or more specifically it has the classes `matrix` and `array`. 

```{r}
class(x[1, , ])
```


I can modify elements in an array by using the assignment operator (`<-` or `=`) like below:

```{r}
x3 <- x2 <- x
x2[1, , ] <- NA
x2

x3[1, , ] <- array(1:8, dim = c(2, 4))
x3
```


## The challenge

### Challenge 1: indexing

Up to this point, it's pretty straight forward. But let's say now we create a function that returns the first element of the first dimension. 

```{r}
index_first <- function(x) {
  x[1, , ]
}

index_first(x)

y <- array(1, dim = c(2, 4, 2))
index_first(y)
```

The above function works fine for the arrays `x` and `y`. But what if the number of dimension is different?

```{r, error = TRUE}
z <- array(dim = c(2, 2, 2, 2))
index_first(z)
```

So how do we change our function so it works for an array of any number of dimensions? This is where it gets quite challenging. And while I'm at it, let me throw another challenge. 

### Challenge 2: assignment

Suppose now I want a function that modifies the entries in the first element of the first dimension by a user supplied value. 

```{r}
modify_first <- function(x, value) {
  x[1, ,] <- value
}
```

```{r}
modify_first(x, NA)
modify_first(x, array(1:8, dim = c(2, 4)))
```

Again this works fine until we have an array with different number of dimensions.

```{r, error = TRUE}
modify_first(z, 1)
```

So how would you modify the function so this can be generalised for arrays with a different number of dimensions?

## Solutions

In the first instance, it's useful to know that the square brackets are in fact functions so the codes below are equivalent:

```{r}
`[`(x, 1, , )
```
```{r}
x[1, , ]
```

The assignment operator for arrays can be written like below where the last argument is the value to replace the indexed array.

```{r}
`[<-`(x2, 1, , , 0)
```

Below is similar. 

```{r}
x2[1, , ] <- 0
```

I say similar because the above actually modifies `x2` but the call before that didn't. Below is the actual equivalent operation. 

```{r}
x2 <- `[<-`(x2, 1, , , 0)
```

<details>
<summary>Solution for indexing</summary>

```{r}
index_first <- function(x) {
  d <- dim(x)
  do.call("[", c(list(x, 1), rep(list(bquote()), length(d) - 1)))
}

index_first(x)
index_first(z)
```

</details>

<details>
<summary>Solution for assignment</summary>

```{r}
modify_first <- function(x, value) {
  d <- dim(x)
  do.call("[<-", c(list(x, 1), rep(list(bquote()), length(d) - 1), list(value)))
}

modify_first(x, 3)
modify_first(z, 3)
```

</details>

## Practice 

So you might wonder when you need such a result. I actually used this for the [`edibble`](https://github.com/emitanaka/edibble) R-package to create a kind of generalised version of Latin square design, i.e. an array that kind of stitches up multiple Latin squares.  

```{r}
set.seed(1)
edibble::latin_array(dim = c(3, 3, 3), nt = 3)
```

Beyond the above, I'm not sure who needs to manipulate arrays with dynamic dimensions. If you have a use case, I'd love to know.


## Advanced R Programming unit

The above challenges are sort of challenges that I hope to include in the Advanced R Programming unit that's planned for Honours level in the Business Analytics major at Monash University. If you want to learn more about R as a programming lanuage (instead of a data analysis tool) then I'd recommend the [Advanced R book by Hadley Wickham](https://adv-r.hadley.nz/). 

```{r, echo = FALSE}
knitr::include_graphics("https://www.r-project.org/Rlogo.png")
```

